<!-- START IMPORTS -->
<script src="./libs/sigma.min.js"></script>
<script src="./libs/plugins/sigma.plugins.animate.min.js"></script>
<script src="./libs/traits.js"></script>
<script src="./libs/underscore.js"></script>
<script src="./libs/context-traits.js"></script>
<script type="text/javascript" src="./cop-langs.json"></script>
<!-- END  IMPORTS -->

<style>
  #container {
	  min-height:100%;
	  position:relative;
  }
  #title {
    padding:10px;
  }
  #graph-container {
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    position: absolute;
    padding-bottom:100px;
  }
  #footer {
     width:100%;
     height:50px;
     position:absolute;
     bottom:0;
     left:0;
  }
</style>

<div id="container">
  <div id="Title">
    <center><h2>COP languages landscape visualization </h2></center>
  </div>
  <div id="graph-container"></div>
  <div id="footer"> </div>
</div>

<script>

function loadJSON(callback) {
   var xobj = new XMLHttpRequest();
   xobj.overrideMimeType("application/json");
   xobj.open('GET', './cop-langs.json', true);
   xobj.onreadystatechange = function () {
     if (xobj.readyState == 4 ) {//&& xobj.status == "200") {
      callback(xobj.responseText);
    }
  }
  xobj.send(null);
}

var languages = [];
var contexts = [];
var graph = {
  nodes: [],
  edges: []
};


UIElements = Trait({
  displayGraph: function() {
    var i, s, step = 0;
    // Instantiate sigma:
    s = new sigma({
      graph: graph,
      container: 'graph-container',
    });
    /*
    setInterval(function() {
      var prefix = ['grid_', 'circular_'][step = +!step];
      sigma.plugins.animate(
        s,
        {
          x: prefix + 'x',
          y: prefix + 'y',
          size: prefix + 'size',
          color: prefix + 'color'
        }
      );
    }, 2000);
    */
  },
  generateEdges: function() {
    //console.log("edges");
      /*
      for (i = 0; i < E; i++)
        g.edges.push({
          id: 'e' + i,
          source: 'n' + (Math.random() * N | 0),
          target: 'n' + (Math.random() * N | 0)
        });
        */
  }
});

var ui = Trait.create(Object.prototype, UIElements);

 // Call to function with anonymous callback
loadJSON(function(response) {
  // Do Something with the response e.g.
  languages = JSON.parse(response);
  generateButtons();
  generateContexts()
  generateNodes();
  ui.displayGraph();
});

function generateContexts() {
  for(key in languages[0]) {
     if(key != "language") {
       contexts[contexts.length] = new Context({ name: key});
     }
   }
};

function generateButtons() {
  for(key in languages[0]) {
	   if(key != "language") {
       var buttonnode = document.createElement('input');
       buttonnode.setAttribute('type','button');
       buttonnode.setAttribute('name',key);
       buttonnode.setAttribute('value',key);
       buttonnode.setAttribute('onclick', "operation(this.name); animate()");
       document.getElementById("footer").appendChild(buttonnode);
     }
   }
};

function operation(buttonname) {
  for(var i=0; i<contexts.length; i++) {
    if(buttonname == contexts[i].name()) {
      alert(contexts[i].name() + " Context activation");
      if(contexts[i].isActive())
        contexts[i].deactivate();
      else {
        contexts[i].activate();
      }
    }
  }
  console.log(contexts);
}

// Generate graph nodes from the available languages:
function generateNodes() {
  var o, L = 100, N = languages.length;
  for (var i = 0; i < N; i++) {
    o = {
      id: 'n' + i,
      label: languages[i].language,
      circular_x: L * Math.cos(Math.PI * 2 * i / N - Math.PI / 2),
      circular_y: L * Math.sin(Math.PI * 2 * i / N - Math.PI / 2),
      circular_size: Math.random(),
      circular_color: '#' + (
        Math.floor(Math.random() * 16777215).toString(16) + '000000'
      ).substr(0, 6),
      grid_x: i % L,
      grid_y: Math.floor(i / L),
      grid_size: 1,
      grid_color: '#ccc'
    };
    ['x', 'y', 'size', 'color'].forEach(function(val) {
      o[val] = o['grid_' + val];
    });
    graph.nodes.push(o);
  }
};

function animate() {
  alert('Clicked');
  generateEdges();
};

</script>
